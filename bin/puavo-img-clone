#!/bin/bash
#
# ##############################################################################
#
# Copyright (C) 2014 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# ##############################################################################
#
# Author: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
#

set -eu

on_exit()
{
    exitval=$?

    set +eu

    umount "${src_filepath_G}"
    rmdir "${src_fsroot_G}"

    return ${exitval}
}

usage_error()
{
    echo "error: $1" >&2
    echo "Try '$0 --help' for more information". >&2
    return 1
}

is_uint()
{
    case $1 in
        ''|*[!0-9]*)
            return 1
            ;;
        *)
            ;;
    esac
    return 0
}

clone_to_ext4()
{
    local dst_loopdev
    local imgname
    local retval
    local src_size
    local tmpdir
    local tmpfile

    imgname=$(basename "${dst_filepath_G}" .img) || return $?

    src_size=$(df --block-size=1 --output=size "${src_fsroot_G}" | tail -n1)
    if [ -z "${src_size}" ]; then
        echo "error: failed to determine the size of the source filesystem" >&2
        return 1
    fi

    if [ -z "${dst_size_G}" ]; then
        dst_size_G=$((src_size * 2))
    fi

    tmpfile=$(mktemp) || return $?

    dd if=/dev/zero of="${tmpfile}" count=0 bs=1 seek="${dst_size_G}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return $retval
    }

    dst_loopdev=$(losetup -f --show "${tmpfile}") || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return $retval
    }

    mkfs.ext4 "${dst_loopdev}" || {
        retval=$?
        losetup -d "${dst_loopdev}" || true
        rm -rf "${tmpfile}" || true
        return $retval
    }

    losetup -d "${dst_loopdev}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return $retval
    }

    tmpdir=$(mktemp -d) || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return $retval
    }

    mount -o loop "${tmpfile}" "${tmpdir}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        rmdir "${tmpdir}" || true
        return $retval
    }

    rsync -a "${src_fsroot_G}/" "${tmpdir}/" || {
        retval=$?
        # If umount fails, leave everything as it is so that the user
        # can cleanup manually later.
        umount "${tmpdir}" || return $retval
        rmdir "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return $retval
    }

    echo "${imgname}" >"${tmpdir}/etc/ltsp/this_ltspimage_name" || {
        retval=$?
        umount "${tmpdir}" || return $retval
        rmdir "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return $retval
    }

    umount "${tmpdir}" || return $?

    mv "${tmpfile}" "${dst_filepath_G}" || return $?

    rmdir "${tmpdir}"
}

clone_to_squashfs()
{
    local dst_file_dir
    local imgname
    local retval
    local tmpdir
    local tmpfile

    imgname=$(basename "${dst_filepath_G}" .img) || return $?

    tmpdir=$(mktemp -d) || return $?

    rsync -a "${src_fsroot_G}/" "${tmpdir}/" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return $retval
    }

    echo "${imgname}" >"${tmpdir}/etc/ltsp/this_ltspimage_name" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return $retval
    }

    dst_file_dir=$(dirname "${dst_filepath_G}") || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return $retval
    }

    tmpfile=$(mktemp --tmpdir="${dst_file_dir}") || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return $retval
    }

    mksquashfs "${tmpdir}" "${tmpfile}" -noappend -no-recovery || {
        retval=$?
        rm -rf "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return $retval
    }

    mv "${tmpfile}" "${dst_filepath_G}" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return $retval
    }

    rm -rf "${tmpdir}"
}

# Main below

# Declare all global variables here and only here.
clone_func_G=clone_to_ext4
dst_filepath_G=
dst_size_G=
force_G=0
src_filepath_G=
src_fsroot_G=

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            shift
            echo "Usage: $0 SRC DST"
            echo
            echo "Make a copy of a Puavo image file with a new image name."
            echo
            echo "Options:"
            echo "    -t, --type FS_TYPE           destination filesystem type, must be"
            echo "                                 'ext4' (default) or 'squashfs'"
            echo "    -s, --size BYTES             size of the destination image file in bytes,"
            echo "                                 defaults to twice the size of the source image"
            echo "                                 filesystem"
            echo "    -f, --force                  overwrite existing destination file"
            echo "    -h, --help                   print help and exit"
            echo "    -V, --version                print version and exit"
            echo
            exit 0
            ;;
        --type)
            shift
            case $1 in
                ext4)
                    clone_func_G=clone_to_ext4
                    ;;
                squashfs)
                    clone_func_G=clone_to_squashfs
                    ;;
                *)
                    usage_error "invalid value '$1' for option '--type', expected 'ext4' or 'squashfs'"
                    ;;
            esac
            shift
            ;;
        --size)
            shift
            dst_size_G=$1
            shift
            is_uint "${dst_size_G}" || {
                usage_error "invalid value '${dst_size_G}' for option '--size', expected unsigned integer"
            }
            ;;
        -f|--force)
            shift
            force_G=1
            ;;
        -V|--version)
            shift
            echo 0.1
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            usage_error "invalid argument '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [ $# -ne 2 ]; then
    usage_error "invalid number of arguments ($#), expected 2"
fi

src_filepath_G=$(readlink -e $1)
dst_filepath_G=$(readlink -f $2)

if [ ${force_G} -eq 0 -a -f "${dst_filepath_G}" ]; then
    echo "error: destination file '${dst_filepath_G}' already exists, use --force to overwrite" >&2
    exit 1
fi

trap on_exit EXIT

src_fsroot_G=$(mktemp -d)

mount -o loop,ro "${src_filepath_G}" "${src_fsroot_G}"
${clone_func_G}
