#!/bin/bash
#
# ##############################################################################
#
# Copyright (C) 2014 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# ##############################################################################
#
# Author: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
#

set -eu

on_exit()
{
    exitval=$?

    set +eu

    umount "${srcfile_G}"
    rmdir "${srcmountdir_G}"

    return ${exitval}
}

usage_error()
{
    echo "error: $1" >&2
    echo "Try '$0 --help' for more information". >&2
    return 1
}

clone_to_ext4()
{
    local dstdir
    local loopdev
    local retval
    local srcsize
    local tmpdir
    local tmpfile

    srcsize=$(du --bytes --summarize "${srcmountdir_G}" | cut -f1)
    if [ -z "${srcsize}" ]; then
        echo "error: failed to estimate the size of the source filesystem" >&2
        return 1
    fi

    if [ -z "${dstsize_G}" ]; then
        dstsize_G=$((srcsize * 2))
    fi

    dstdir=$(dirname "${dstfile_G}") || return $?

    tmpfile=$(mktemp --tmpdir="${dstdir}") || return $?

    qemu-img create -f raw "${tmpfile}" "${dstsize_G}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    loopdev=$(losetup -f --show "${tmpfile}") || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    mkfs.ext4 "${loopdev}" || {
        retval=$?
        losetup -d "${loopdev}" || true
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    losetup -d "${loopdev}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    tmpdir=$(mktemp -d) || {
        retval=$?
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    mount -o loop "${tmpfile}" "${tmpdir}" || {
        retval=$?
        rm -rf "${tmpfile}" || true
        rmdir "${tmpdir}" || true
        return ${retval}
    }

    rsync -a "${srcmountdir_G}/" "${tmpdir}/" || {
        retval=$?
        # If umount fails, leave everything as it is so that the user
        # can cleanup manually later.
        umount "${tmpdir}" || return ${retval}
        rmdir "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    echo "${imgname_G}" >"${tmpdir}/etc/ltsp/this_ltspimage_name" || {
        retval=$?
        umount "${tmpdir}" || return ${retval}
        rmdir "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    umount "${tmpdir}" || return $?

    mv "${tmpfile}" "${dstfile_G}" || return $?

    rmdir "${tmpdir}"
}

clone_to_squashfs()
{
    local dstdir
    local retval
    local tmpdir
    local tmpfile

    tmpdir=$(mktemp -d) || return $?

    rsync -a "${srcmountdir_G}/" "${tmpdir}/" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return ${retval}
    }

    echo "${imgname_G}" >"${tmpdir}/etc/ltsp/this_ltspimage_name" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return ${retval}
    }

    dstdir=$(dirname "${dstfile_G}") || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return ${retval}
    }

    tmpfile=$(mktemp --tmpdir="${dstdir}") || {
        retval=$?
        rm -rf "${tmpdir}" || true
        return ${retval}
    }

    mksquashfs "${tmpdir}" "${tmpfile}" -noappend -no-recovery || {
        retval=$?
        rm -rf "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    mv "${tmpfile}" "${dstfile_G}" || {
        retval=$?
        rm -rf "${tmpdir}" || true
        rm -rf "${tmpfile}" || true
        return ${retval}
    }

    rm -rf "${tmpdir}"
}

# Main below

# Declare all global variables here and only here.
clonefunc_G=clone_to_ext4
dstfile_G=
dstsize_G=
force_G=0
imgname_G=
srcfile_G=
srcfsroot_G=

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            shift
            echo "Usage: $0 SRC DST"
            echo
            echo "Make a copy of a Puavo image file with a new image name."
            echo
            echo "Options:"
            echo "    -t, --type FS_TYPE           destination filesystem type, must be"
            echo "                                 'ext4' (default) or 'squashfs'"
            echo "    -s, --size SIZE              size of the destination image file, defaults"
            echo "                                 to about twice the size of the source image"
            echo "                                 contents, supports suffixes k, K, M, G and T"
            echo "    -f, --force                  overwrite existing destination file"
            echo "    -h, --help                   print help and exit"
            echo "    -V, --version                print version and exit"
            echo
            exit 0
            ;;
        -t|--type)
            shift
            case $1 in
                ext4)
                    clonefunc_G=clone_to_ext4
                    ;;
                squashfs)
                    clonefunc_G=clone_to_squashfs
                    ;;
                *)
                    usage_error "invalid value '$1' for option '--type', expected 'ext4' or 'squashfs'"
                    ;;
            esac
            shift
            ;;
        -s|--size)
            shift
            dstsize_G=$1
            shift
            sed -r -n '/^[0-9]+[kKMGT]?$/ ! q1' <<<"${dstsize_G}" || {
                usage_error "invalid value '${dstsize_G}' for option '--size'"
            }
            ;;
        -f|--force)
            shift
            force_G=1
            ;;
        -V|--version)
            shift
            echo 0.1
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            usage_error "invalid argument '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [ $# -ne 2 ]; then
    usage_error "invalid number of arguments ($#), expected 2"
fi

srcfile_G=$(readlink -e $1)
dstfile_G=$(readlink -f $2)

if [ ${force_G} -eq 0 -a -f "${dstfile_G}" ]; then
    echo "error: destination file '${dstfile_G}' already exists, use --force to overwrite" >&2
    exit 1
fi

imgname_G=$(basename "${dstfile_G}" .img)

trap on_exit EXIT

srcmountdir_G=$(mktemp -d)

mount -o loop,ro "${srcfile_G}" "${srcmountdir_G}"
${clonefunc_G}
